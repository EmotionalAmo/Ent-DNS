//! API 集成测试
//!
//! 两种测试模式：
//! 1. oneshot 模式：直接调用 router，不绑定端口（适合不需要 ConnectInfo 的端点）
//! 2. bound server 模式：绑定到随机端口，通过真实 HTTP 请求测试（适合 login 等需要 ConnectInfo 的端点）
//!
//! 覆盖端点：
//!   - GET  /health
//!   - POST /api/v1/auth/login  (成功 / 错误密码)
//!   - POST /api/v1/auth/logout
//!   - GET  /api/v1/rules       (需要 Bearer token)
//!   - POST /api/v1/rules       (创建规则)
//!   - DELETE /api/v1/rules/{id}
//!   - GET  /api/v1/query-log   (需要 Bearer token / 参数过滤)

use axum::{
    body::Body,
    http::{Request, StatusCode, header},
};
use serde_json::Value;
use sqlx::SqlitePool;
use std::net::SocketAddr;
use std::sync::Arc;
use std::time::Instant;
use dashmap::DashMap;
use tokio::sync::broadcast;
use tower::ServiceExt; // for .oneshot()
use http_body_util::BodyExt; // for .collect()

// ── 内部 crate 引用 ────────────────────────────────────────────────────────────
// 集成测试与被测试 crate 在同一 workspace，直接引用
use ent_dns::api::{AppState, build_app};
use ent_dns::dns::filter::FilterEngine;
use ent_dns::metrics::DnsMetrics;

/// 构建测试专用 in-memory 数据库，运行所有 migration，并插入 admin 用户。
async fn setup_db() -> SqlitePool {
    let pool = SqlitePool::connect(":memory:")
        .await
        .expect("Failed to create in-memory SQLite pool");

    // 运行所有迁移脚本
    sqlx::migrate!("./src/db/migrations")
        .run(&pool)
        .await
        .expect("Migration failed");

    // 插入测试用 admin 用户（密码: admin）
    let password_hash = ent_dns::auth::password::hash("admin")
        .expect("Failed to hash password");
    let id = uuid::Uuid::new_v4().to_string();
    let now = chrono::Utc::now().to_rfc3339();

    sqlx::query(
        "INSERT INTO users (id, username, password, role, is_active, created_at, updated_at)
         VALUES (?, 'admin', ?, 'super_admin', 1, ?, ?)"
    )
    .bind(&id)
    .bind(&password_hash)
    .bind(&now)
    .bind(&now)
    .execute(&pool)
    .await
    .expect("Failed to seed admin user");

    pool
}

/// 启动真实 TCP 监听的测试服务器，返回绑定地址和 AppState。
/// 用于需要 ConnectInfo（如 login）的测试。
/// 返回的 task handle 在 Drop 时自动终止服务器。
async fn start_test_server() -> (String, Arc<AppState>) {
    let (_, state) = build_test_app().await;

    let cors = tower_http::cors::CorsLayer::new();
    let app = ent_dns::api::build_app(state.clone(), cors);

    // 绑定到随机端口
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0")
        .await
        .expect("Failed to bind test server");
    let addr = listener.local_addr().expect("Failed to get local addr");

    tokio::spawn(async move {
        axum::serve(
            listener,
            app.into_make_service_with_connect_info::<SocketAddr>(),
        )
        .await
        .ok();
    });

    let base_url = format!("http://127.0.0.1:{}", addr.port());
    (base_url, state)
}

/// 构建完整测试 App（不启动 TCP 监听器）。
/// DnsHandler 在集成测试中设为 None-safe 模式：
/// 只测试不涉及 DNS 解析的端点（auth、rules、query-log）。
async fn build_test_app() -> (axum::Router, Arc<AppState>) {
    let db = setup_db().await;
    let filter = Arc::new(
        FilterEngine::new(db.clone())
            .await
            .expect("Failed to build FilterEngine"),
    );
    let metrics = Arc::new(DnsMetrics::default());
    let (query_log_tx, _) = broadcast::channel::<serde_json::Value>(16);

    // 集成测试中不启动真实 DNS handler，
    // 但 AppState 需要 dns_handler: Arc<DnsHandler>。
    // 用一个占位 Arc 绕过：构建最小化 DnsHandler。
    let test_cfg = ent_dns::config::Config {
        dns: ent_dns::config::DnsConfig {
            port: 15399, // 随机高端口，不实际监听
            bind: "127.0.0.1".to_string(),
            upstreams: vec!["https://1.1.1.1/dns-query".to_string()],
            doh_enabled: false,
            dot_enabled: false,
        },
        api: ent_dns::config::ApiConfig {
            port: 18099,
            bind: "127.0.0.1".to_string(),
            cors_allowed_origins: vec!["http://localhost:5173".to_string()],
        },
        database: ent_dns::config::DatabaseConfig {
            path: ":memory:".to_string(),
        },
        auth: ent_dns::config::AuthConfig {
            jwt_secret: "test-jwt-secret-for-integration-tests-only-32chars".to_string(),
            jwt_expiry_hours: 1,
        },
    };

    let dns_handler = ent_dns::dns::build_handler(
        &test_cfg,
        db.clone(),
        filter.clone(),
        metrics.clone(),
        query_log_tx.clone(),
    )
    .await
    .expect("Failed to build DnsHandler");

    let jwt_secret = test_cfg.auth.jwt_secret.clone();
    let state = Arc::new(AppState {
        db,
        filter,
        jwt_secret,
        jwt_expiry_hours: 1,
        metrics,
        query_log_tx,
        ws_tickets: DashMap::new(),
        login_attempts: DashMap::new(),
        dns_handler,
    });

    // CORS 层用空配置（测试中不需要）
    let cors = tower_http::cors::CorsLayer::new();
    let app = build_app(state.clone(), cors);
    (app, state)
}

/// 辅助：从响应 Body 读取 JSON Value
async fn body_json(body: axum::body::Body) -> Value {
    let bytes = body
        .collect()
        .await
        .expect("Failed to collect body")
        .to_bytes();
    serde_json::from_slice(&bytes).expect("Body is not valid JSON")
}

// ═══════════════════════════════════════════════════════════════════════════════
// Health Check
// ═══════════════════════════════════════════════════════════════════════════════

#[tokio::test]
async fn test_health_check() {
    let (app, _) = build_test_app().await;

    let req = Request::builder()
        .method("GET")
        .uri("/health")
        .body(Body::empty())
        .unwrap();

    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::OK);
}

// ═══════════════════════════════════════════════════════════════════════════════
// Auth: Login
// login handler 使用 ConnectInfo<SocketAddr>，需要绑定到真实端口的 HTTP 请求
// ═══════════════════════════════════════════════════════════════════════════════

#[tokio::test]
async fn test_login_success_returns_token() {
    let (base_url, _) = start_test_server().await;

    let client = reqwest::Client::new();
    let resp = client
        .post(format!("{}/api/v1/auth/login", base_url))
        .json(&serde_json::json!({"username": "admin", "password": "admin"}))
        .send()
        .await
        .expect("Request failed");

    assert_eq!(resp.status().as_u16(), 200);
    let json: Value = resp.json().await.expect("Failed to parse JSON");
    assert!(json["token"].is_string(), "Response should contain a token");
    assert_eq!(json["role"], "super_admin");
    assert!(json["expires_in"].is_number());
}

#[tokio::test]
async fn test_login_wrong_password_returns_401() {
    let (base_url, _) = start_test_server().await;

    let client = reqwest::Client::new();
    let resp = client
        .post(format!("{}/api/v1/auth/login", base_url))
        .json(&serde_json::json!({"username": "admin", "password": "wrongpassword"}))
        .send()
        .await
        .expect("Request failed");

    assert_eq!(resp.status().as_u16(), 401);
}

#[tokio::test]
async fn test_login_unknown_user_returns_401() {
    let (base_url, _) = start_test_server().await;

    let client = reqwest::Client::new();
    let resp = client
        .post(format!("{}/api/v1/auth/login", base_url))
        .json(&serde_json::json!({"username": "nonexistent", "password": "anything"}))
        .send()
        .await
        .expect("Request failed");

    assert_eq!(resp.status().as_u16(), 401);
}

#[tokio::test]
async fn test_login_rate_limit_after_5_failures() {
    let (base_url, state) = start_test_server().await;

    // 预先将 127.0.0.1 的失败次数设为 5（MAX_LOGIN_FAILURES）
    let ip = "127.0.0.1";
    state.login_attempts.insert(
        ip.to_string(),
        (5u32, Instant::now()),
    );

    // 第 6 次登录应触发限速（即使密码正确）
    let client = reqwest::Client::new();
    let resp = client
        .post(format!("{}/api/v1/auth/login", base_url))
        .json(&serde_json::json!({"username": "admin", "password": "admin"}))
        .send()
        .await
        .expect("Request failed");

    assert_eq!(resp.status().as_u16(), 429, "Should be rate limited after 5 failures");
}

// ═══════════════════════════════════════════════════════════════════════════════
// Auth: Protected routes without token
// ═══════════════════════════════════════════════════════════════════════════════

#[tokio::test]
async fn test_protected_route_without_token_returns_401() {
    let (app, _) = build_test_app().await;

    let req = Request::builder()
        .method("GET")
        .uri("/api/v1/rules")
        .body(Body::empty())
        .unwrap();

    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);
}

#[tokio::test]
async fn test_protected_route_with_invalid_token_returns_401() {
    let (app, _) = build_test_app().await;

    let req = Request::builder()
        .method("GET")
        .uri("/api/v1/rules")
        .header(header::AUTHORIZATION, "Bearer invalid.jwt.token")
        .body(Body::empty())
        .unwrap();

    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);
}

// ═══════════════════════════════════════════════════════════════════════════════
// Auth: Logout
// ═══════════════════════════════════════════════════════════════════════════════

#[tokio::test]
async fn test_logout_always_succeeds() {
    let (app, _) = build_test_app().await;

    let req = Request::builder()
        .method("POST")
        .uri("/api/v1/auth/logout")
        .body(Body::empty())
        .unwrap();

    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::OK);
    let json = body_json(resp.into_body()).await;
    assert_eq!(json["success"], true);
}

// ═══════════════════════════════════════════════════════════════════════════════
// Rules CRUD
// ═══════════════════════════════════════════════════════════════════════════════

#[tokio::test]
async fn test_list_rules_requires_auth() {
    let (app, _) = build_test_app().await;

    let req = Request::builder()
        .method("GET")
        .uri("/api/v1/rules")
        .body(Body::empty())
        .unwrap();

    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);
}

#[tokio::test]
async fn test_list_rules_with_valid_token() {
    let (app, state) = build_test_app().await;

    // 直接生成 token，不走 login HTTP 路径（绕过 ConnectInfo 限制）
    let token = ent_dns::auth::jwt::generate(
        "test-user-id", "admin", "super_admin",
        &state.jwt_secret, 1,
    ).expect("Should generate token");

    let req = Request::builder()
        .method("GET")
        .uri("/api/v1/rules")
        .header(header::AUTHORIZATION, format!("Bearer {}", token))
        .body(Body::empty())
        .unwrap();

    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::OK);
    let json = body_json(resp.into_body()).await;
    assert!(json["data"].is_array(), "Response should have data array");
    assert!(json["total"].is_number());
}

#[tokio::test]
async fn test_create_rule_and_list() {
    let (app, state) = build_test_app().await;

    let token = ent_dns::auth::jwt::generate(
        "test-user-id", "admin", "super_admin",
        &state.jwt_secret, 1,
    ).expect("Should generate token");

    // 创建规则
    let create_req = Request::builder()
        .method("POST")
        .uri("/api/v1/rules")
        .header(header::AUTHORIZATION, format!("Bearer {}", token))
        .header(header::CONTENT_TYPE, "application/json")
        .body(Body::from(r#"{"rule":"||test-block.example.com^","comment":"integration test rule"}"#))
        .unwrap();

    let create_resp = app.clone().oneshot(create_req).await.unwrap();
    assert_eq!(create_resp.status(), StatusCode::OK, "Rule creation should succeed");
    let created = body_json(create_resp.into_body()).await;
    assert_eq!(created["rule"], "||test-block.example.com^");
    assert!(created["id"].is_string(), "Created rule should have an ID");

    let rule_id = created["id"].as_str().unwrap().to_string();

    // 列出规则，验证刚创建的规则存在
    let list_req = Request::builder()
        .method("GET")
        .uri("/api/v1/rules")
        .header(header::AUTHORIZATION, format!("Bearer {}", token))
        .body(Body::empty())
        .unwrap();

    let list_resp = app.clone().oneshot(list_req).await.unwrap();
    assert_eq!(list_resp.status(), StatusCode::OK);
    let list_json = body_json(list_resp.into_body()).await;
    let data = list_json["data"].as_array().unwrap();
    let found = data.iter().any(|r| r["id"] == rule_id);
    assert!(found, "Newly created rule should appear in list");

    // 删除规则
    let delete_req = Request::builder()
        .method("DELETE")
        .uri(format!("/api/v1/rules/{}", rule_id))
        .header(header::AUTHORIZATION, format!("Bearer {}", token))
        .body(Body::empty())
        .unwrap();

    let delete_resp = app.clone().oneshot(delete_req).await.unwrap();
    assert_eq!(delete_resp.status(), StatusCode::OK);
    let delete_json = body_json(delete_resp.into_body()).await;
    assert_eq!(delete_json["success"], true);

    // 再次列出，确认规则已删除
    let list_req2 = Request::builder()
        .method("GET")
        .uri("/api/v1/rules")
        .header(header::AUTHORIZATION, format!("Bearer {}", token))
        .body(Body::empty())
        .unwrap();

    let list_resp2 = app.oneshot(list_req2).await.unwrap();
    let list_json2 = body_json(list_resp2.into_body()).await;
    let data2 = list_json2["data"].as_array().unwrap();
    let still_found = data2.iter().any(|r| r["id"] == rule_id);
    assert!(!still_found, "Deleted rule should not appear in list");
}

#[tokio::test]
async fn test_create_rule_empty_body_returns_400() {
    let (app, state) = build_test_app().await;

    let token = ent_dns::auth::jwt::generate(
        "test-user-id", "admin", "super_admin",
        &state.jwt_secret, 1,
    ).expect("Should generate token");

    let req = Request::builder()
        .method("POST")
        .uri("/api/v1/rules")
        .header(header::AUTHORIZATION, format!("Bearer {}", token))
        .header(header::CONTENT_TYPE, "application/json")
        .body(Body::from(r#"{"rule":""}"#))
        .unwrap();

    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::BAD_REQUEST, "Empty rule should be rejected");
}

#[tokio::test]
async fn test_delete_nonexistent_rule_returns_404() {
    let (app, state) = build_test_app().await;

    let token = ent_dns::auth::jwt::generate(
        "test-user-id", "admin", "super_admin",
        &state.jwt_secret, 1,
    ).expect("Should generate token");

    let req = Request::builder()
        .method("DELETE")
        .uri("/api/v1/rules/nonexistent-uuid-12345")
        .header(header::AUTHORIZATION, format!("Bearer {}", token))
        .body(Body::empty())
        .unwrap();

    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::NOT_FOUND);
}

// ═══════════════════════════════════════════════════════════════════════════════
// Query Log
// ═══════════════════════════════════════════════════════════════════════════════

#[tokio::test]
async fn test_query_log_requires_auth() {
    let (app, _) = build_test_app().await;

    let req = Request::builder()
        .method("GET")
        .uri("/api/v1/query-log")
        .body(Body::empty())
        .unwrap();

    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);
}

#[tokio::test]
async fn test_query_log_empty_result() {
    let (app, state) = build_test_app().await;

    let token = ent_dns::auth::jwt::generate(
        "test-user-id", "admin", "super_admin",
        &state.jwt_secret, 1,
    ).expect("Should generate token");

    let req = Request::builder()
        .method("GET")
        .uri("/api/v1/query-log")
        .header(header::AUTHORIZATION, format!("Bearer {}", token))
        .body(Body::empty())
        .unwrap();

    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::OK);
    let json = body_json(resp.into_body()).await;
    assert!(json["data"].is_array());
    assert_eq!(json["total"], 0);
}

#[tokio::test]
async fn test_query_log_with_status_filter() {
    let (app, state) = build_test_app().await;

    // 插入测试日志数据
    let now = chrono::Utc::now().to_rfc3339();
    sqlx::query(
        "INSERT INTO query_log (time, client_ip, question, qtype, status, elapsed_ms)
         VALUES (?, '192.168.1.1', 'blocked.example.com', 'A', 'blocked', 1)"
    )
    .bind(&now)
    .execute(&state.db)
    .await
    .expect("Failed to insert test log");

    sqlx::query(
        "INSERT INTO query_log (time, client_ip, question, qtype, status, elapsed_ms)
         VALUES (?, '192.168.1.1', 'allowed.example.com', 'A', 'allowed', 5)"
    )
    .bind(&now)
    .execute(&state.db)
    .await
    .expect("Failed to insert test log");

    let token = ent_dns::auth::jwt::generate(
        "test-user-id", "admin", "super_admin",
        &state.jwt_secret, 1,
    ).expect("Should generate token");

    // 过滤 status=blocked
    let req = Request::builder()
        .method("GET")
        .uri("/api/v1/query-log?status=blocked")
        .header(header::AUTHORIZATION, format!("Bearer {}", token))
        .body(Body::empty())
        .unwrap();

    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::OK);
    let json = body_json(resp.into_body()).await;
    let data = json["data"].as_array().unwrap();
    assert_eq!(json["total"], 1, "Should find exactly 1 blocked entry");
    assert!(data.iter().all(|r| r["status"] == "blocked"), "All results should be blocked");
}

#[tokio::test]
async fn test_query_log_pagination_limit() {
    let (app, state) = build_test_app().await;

    // 插入 5 条日志
    let now = chrono::Utc::now().to_rfc3339();
    for i in 0..5 {
        sqlx::query(
            "INSERT INTO query_log (time, client_ip, question, qtype, status, elapsed_ms)
             VALUES (?, '10.0.0.1', ?, 'A', 'allowed', 1)"
        )
        .bind(&now)
        .bind(format!("domain{}.com", i))
        .execute(&state.db)
        .await
        .expect("Failed to insert");
    }

    let token = ent_dns::auth::jwt::generate(
        "test-user-id", "admin", "super_admin",
        &state.jwt_secret, 1,
    ).expect("Should generate token");

    // 请求 limit=2
    let req = Request::builder()
        .method("GET")
        .uri("/api/v1/query-log?limit=2")
        .header(header::AUTHORIZATION, format!("Bearer {}", token))
        .body(Body::empty())
        .unwrap();

    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::OK);
    let json = body_json(resp.into_body()).await;
    assert_eq!(json["returned"], 2, "Should return exactly 2 entries");
    assert_eq!(json["total"], 5, "Total should be 5");
    assert_eq!(json["limit"], 2);
}
